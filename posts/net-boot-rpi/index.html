<!DOCTYPE html>
<html lang="en-us">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Adventures in booting Linux on Raspberry Pi 4</title>
    <meta property="og:title" content="Adventures in booting Linux on Raspberry Pi 4" />
<meta property="og:description" content="Almost two months ago, I started building a four node Raspberry Pi 4 cluster for a project I’m working on. Figuring out the best way to get Linux on each node lead me down a rabbit hole and I spent the next four weeks yak shaving.
The most common way to boot a Pi is from an SD card. But they are slow and unreliable - I don&rsquo;t like them. Certain models of Pi 2 and Pi 3 support booting from USB storage, but Pi 4 cannot do that yet." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://blog.mostlypointless.dev/posts/net-boot-rpi/" />
<meta property="article:published_time" content="2020-06-26T00:00:00-07:00" />
<meta property="article:modified_time" content="2020-06-26T00:00:00-07:00" />
<link rel="stylesheet" href="https://blog.mostlypointless.dev/css/style.css">
</head>
<body>
<header>
    <b>
        <a href="https://blog.mostlypointless.dev/">a (mostly) pointless blog</a>
    </b>
<nav>
    
    <a href="/">Home</a> |
    
    <a href="https://github.com/vamc19">Github</a> |
    
    <a href="/index.xml">RSS</a>
    </nav>
</header>
<hr/>

<main>
    <article>
        <h1>Adventures in booting Linux on Raspberry Pi 4</h1>
        
            <span class="pubdate"> Jun 26, 2020</span>
            
                <a href="/tags/linux">linux</a>
            
                <a href="/tags/raspberry-pi">raspberry pi</a>
            
        
        <p>Almost two months ago, I started building a four node Raspberry Pi 4 cluster for a project I’m working on. Figuring out the best way to get Linux on each node lead me down a rabbit hole and I spent the next four weeks <a href="http://www.catb.org/~esr/jargon/html/Y/yak-shaving.html">yak shaving</a>.</p>
<p>The most common way to boot a Pi is from an SD card. But they are slow and unreliable - I don&rsquo;t like them. Certain models of Pi 2 and Pi 3 support <a href="https://www.raspberrypi.org/documentation/hardware/raspberrypi/bootmodes/msd.md">booting from USB storage</a>, but Pi 4 cannot do that yet. So, I’m stuck with using an SD card for each Pi. Or so I thought.</p>
<h3 id="enter-pxe-boot">Enter PXE boot</h3>
<p>Turns out, Raspberry Pi 2 and 3 also <a href="https://www.raspberrypi.org/documentation/hardware/raspberrypi/bootmodes/net.md">support network booting</a>. A beta firmware was released late last year that enables <a href="https://en.wikipedia.org/wiki/Preboot_Execution_Environment">PXE</a> for Pi 4. I found <a href="https://linuxhit.com/raspberry-pi-pxe-boot-netbooting-a-pi-4-without-an-sd-card">an article on LinuxHit</a> detailing the process of installing the firmware and setting up network boot.</p>
<p>Just to test this out, I updated the firmware and configured PXE server on one of the Pis. I tried booting another Pi over the network and&hellip;it worked!
Here is the gist of PXE server setup process:</p>
<ol>
<li>Copy the contents of <code>/boot</code> and the rest of <code>/</code> into separate folders on your local filesystem. I copied mine to <code>/tftp/raspbian-boot</code> and <code>/nfs/raspbian-root</code> respectively.</li>
<li>Install and configure <code>dnsmasq</code> to enable TFTP and use <code>/tftp</code> as <code>tftp-root</code></li>
<li>Install and configure NFS server to share <code>/tftp/raspbian-boot</code> and <code>/nfs/raspbian-root</code></li>
<li>Edit the contents of <code>/nfs/raspbian-root/fstab</code> to mount the boot partition.</li>
<li>Edit <code>/nfs/raspbian-boot/cmdline.txt</code> to</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">console<span style="color:#f92672">=</span>serial0,115200 console<span style="color:#f92672">=</span>tty1 root<span style="color:#f92672">=</span>/dev/nfs nfsroot<span style="color:#f92672">=</span>&lt;IP addr&gt;:/nfs/raspbian-root,vers<span style="color:#f92672">=</span>4.1,proto<span style="color:#f92672">=</span>tcp rw ip<span style="color:#f92672">=</span>dhcp rootwait elevator<span style="color:#f92672">=</span>deadline
</code></pre></div><h3 id="pxe-booting-3-nodes">PXE booting 3 nodes</h3>
<p>I cannot just boot all three nodes from the same boot and root filesystems since they are not read-only (and I don’t want to maintain a copy for each node). I’ll instead do what Docker does - create OverlayFS for each node using raspbian-root and raspbian-boot as my lower dirs. I’ll share them over NFS like before.</p>
<p>Configuration for one of the nodes is below. Other two nodes follow the same pattern. Note that I moved raspbian-root and raspbian-boot to a USB drive (mounted at <code>/mnt</code>) to get better r/w performance.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ mount -t overlay nog-boot -o lowerdir<span style="color:#f92672">=</span>/mnt/raspbian-boot,upperdir<span style="color:#f92672">=</span>/mnt/upper/nog-boot,workdir<span style="color:#f92672">=</span>/mnt/work/nog-boot -o nfs_export<span style="color:#f92672">=</span>on -o index<span style="color:#f92672">=</span>on -o redirect_dir<span style="color:#f92672">=</span>nofollow /tftpboot/dc-a6-32-XX-XX-XX  
<span style="color:#75715e"># dc-a6-32-XX-XX-XX is the MAC address of the Pi. See dnsmasq’s tftp-unique-root option to know why :)</span> 

$ mount -t overlay nog-root -o lowerdir<span style="color:#f92672">=</span>/mnt/raspbian-root,upperdir<span style="color:#f92672">=</span>/mnt/work/nog-root,workdir<span style="color:#f92672">=</span>/mnt/work/nog-root -o nfs_export<span style="color:#f92672">=</span>on -o index<span style="color:#f92672">=</span>on -o redirect_dir<span style="color:#f92672">=</span>nofollow /nfs/nog

$ cat /tftpboot/dc-a6-32-XX-XX-XX/cmdline.txt
console<span style="color:#f92672">=</span>serial0,115200 console<span style="color:#f92672">=</span>tty1 root<span style="color:#f92672">=</span>/dev/nfs nfsroot<span style="color:#f92672">=</span>&lt;IP addr&gt;:/nfs/nog,vers<span style="color:#f92672">=</span>4.1,proto<span style="color:#f92672">=</span>tcp rw ip<span style="color:#f92672">=</span>dhcp rootwait elevator<span style="color:#f92672">=</span>deadline
</code></pre></div><p>(In case you are wondering what <code>nog</code> is: I name my servers after planets from the Star Wars universe. Following this tradition, I’ve named the Pis Mandalore (PXE server), Nog, Ordo and Werda)</p>
<p>You are probably thinking that this worked. It did not.</p>
<p>NFS and OverlayFS did not play nice with each other. After a weekend trying to work around weird issues, I gave up.</p>
<p>But OverlayFS is not the only copy-on-write filesystem in existence, is it? ZFS and BTRFS offer <a href="https://btrfs.wiki.kernel.org/index.php/Manpage/btrfs-subvolume">subvolumes and snapshots</a> that I can use instead. But not before I <del>procrastinate</del> spend 2 weeks deciding which one to use.</p>
<h3 id="moving-to-btrfs">Moving to BTRFS</h3>
<p>The plan is simple: I’ll create a subvolume each for raspbian-root and raspbian-boot. I’ll then create three snapshots of each subvolume - one for every node. I created a <a href="https://en.wikipedia.org/wiki/RAS_syndrome">btrfs file system</a> on my external drive and ran the following commands</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ btrfs subvolume create raspbian-root
$ btrfs subvolume create raspbian-boot

<span style="color:#75715e"># Repeat the following for each node changing folder names as necessary</span>
$ btrfs subvolume snapshot raspbian-boot nog-boot
$ btrfs subvolume snapshot raspbian-root nog-root
$ mount --bind /mnt/nog-boot /tftpboot/dc-a6-32-XX-XX-XX
$ mount --bind /mnt/nog-root /nfs/nog

<span style="color:#75715e"># Don’t forget to edit cmdline.txt for each node</span>
$ cat /tftpboot/dc-a6-32-XX-XX-XX/cmdline.txt
console<span style="color:#f92672">=</span>serial0,115200 console<span style="color:#f92672">=</span>tty1 root<span style="color:#f92672">=</span>/dev/nfs nfsroot<span style="color:#f92672">=</span>&lt;IP addr&gt;:/nfs/nog,vers<span style="color:#f92672">=</span>4.1,proto<span style="color:#f92672">=</span>tcp rw ip<span style="color:#f92672">=</span>dhcp rootwait elevator<span style="color:#f92672">=</span>deadline
</code></pre></div><p>Well, this worked! Now all I have to do is create systemd unit files to start all required services and mount snapshots. I can finally start working on my project.</p>
<p>Wait a minute. Take a closer look at the output of <code>cat /tftpboot/dc-a6-32-XX-XX-XX/cmdline.txt</code>.
If you are like me, you will realize for the first time that <code>root=</code> in this file defines where the root filesystem will be mounted from. Right now, we are telling it to mount from <code>/dev/nfs</code>. What if I attach an external drive and set <code>root=</code> to point to the external drive?</p>
<h3 id="network-booting-into-an-external-drive">Network booting into an external drive</h3>
<p>RPi 4 cannot directly boot from a USB drive. As in - it cannot find <code>/boot</code> on a USB drive when powering on. But what if we provide <code>/boot</code> with network boot and mount <code>/</code> from a USB drive using <code>cmdline.txt</code>? Time to test.</p>
<p>I copied raspbian-root to a USB drive, edited <code>etc/fstab</code> to mount <code>/</code> using the partition’s PARTUUID and connected it to Nog. I then updated the contents of <code>/tftpboot/dc-a6-32-XX-XX-XX/cmdline.txt</code>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ cat /tftpboot/dc-a6-32-XX-XX-XX/cmdline.txt
 console<span style="color:#f92672">=</span>serial0,115200 console<span style="color:#f92672">=</span>tty1 root<span style="color:#f92672">=</span>PARTUUID<span style="color:#f92672">=</span>c1f95d14-01 rootfstype<span style="color:#f92672">=</span>ext4 elevator<span style="color:#f92672">=</span>deadline fsck.repair<span style="color:#f92672">=</span>yes rootwait
</code></pre></div><p>After a couple of reboots, it worked! I now have a RPi 4 running off a USB hard drive!</p>
<h3 id="what-did-i-gain">What did I gain?</h3>
<p>Let’s look at some read/write performance numbers I got using the following commands:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sync; dd <span style="color:#66d9ef">if</span><span style="color:#f92672">=</span>/dev/zero of<span style="color:#f92672">=</span>twogeefile bs<span style="color:#f92672">=</span>1M count<span style="color:#f92672">=</span>2048; sync
$ sudo sh -c <span style="color:#e6db74">&#34;sync &amp;&amp; echo 3 &gt; /proc/sys/vm/drop_caches&#34;</span>
$ dd <span style="color:#66d9ef">if</span><span style="color:#f92672">=</span>twogeefile of<span style="color:#f92672">=</span>/dev/null bs<span style="color:#f92672">=</span>1M count<span style="color:#f92672">=</span><span style="color:#ae81ff">2048</span>
</code></pre></div><table>
<thead>
<tr>
<th>Storage</th>
<th align="right">Read (MB/s)</th>
<th align="right">Write (MB/s)</th>
</tr>
</thead>
<tbody>
<tr>
<td>Sandisk Ultra MicroSDXC Class 10</td>
<td align="right">45.7</td>
<td align="right">20.2</td>
</tr>
<tr>
<td>Network Boot with BTRFS</td>
<td align="right">63.3</td>
<td align="right">18.8</td>
</tr>
<tr>
<td><code>/</code> mounted from external drive</td>
<td align="right">113</td>
<td align="right">92.7</td>
</tr>
</tbody>
</table>
<p>That is a substantial improvement, I&rsquo;d say.</p>
<p>Note that the external drives I used are old 5400RPM hard disks repurposed from old MacBooks. I bought them on eBay for $10 a pop. YMMV</p>
<h3 id="current-setup">Current setup</h3>
<p>Right now, I have Mandalore booting from an SD card and <code>/</code> mounted from a USB hard disk. Nog, Ordo and Werda fetch <code>/boot</code> from Mandalore over the network and <code>/</code> mounted from a USB hard disk.</p>
<p>I can finally start working on my proj… wait, what?</p>
<p><a href="https://www.tomshardware.com/how-to/boot-raspberry-pi-4-usb">A new beta firmware is out for RPi 4 that lets you boot from USB drives directly.</a></p>
<p>Oh well…</p>
<p>¯\_(ツ)_/¯</p>

        
    </article>
</main>
<hr/>
<footer>
    Except where noted otherwise, content on this website is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a><br>
Built with <a href="https://gohugo.io">Hugo</a> | Hosted on <a href="https://pages.github.com">Github Pages</a> | Github&rsquo;s <a href="https://github.com/site/privacy">Privacy Policy</a>
</footer>


